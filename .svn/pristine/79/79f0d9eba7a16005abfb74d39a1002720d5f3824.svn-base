package com.capinfo.wdbl.service;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.sql.SQLException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Map;
import java.util.UUID;

import org.apache.commons.io.FileUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.poi.hwpf.HWPFDocument;
import org.apache.poi.hwpf.usermodel.Bookmark;
import org.apache.poi.hwpf.usermodel.Range;
import org.apache.poi.hwpf.usermodel.Section;
import org.apache.poi.xwpf.usermodel.Document;
import org.hibernate.HibernateException;
import org.hibernate.Query;
import org.hibernate.Session;
import org.hibernate.transform.Transformers;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.orm.hibernate3.HibernateCallback;
import org.springframework.orm.hibernate3.HibernateTemplate;
import org.springframework.stereotype.Service;
import org.springframework.util.Assert;
import org.springframework.util.StringUtils;

import com.capinfo.wdbl.bean.FileReg;
import com.capinfo.wdbl.dao.FileRegDao;
import com.capinfo.wdbl.enums.DocType;
import com.capinfo.wdbl.util.BarCodeUtil;
import com.capinfo.wdbl.util.WordOperator;

@Service
public class FileRegExportServiceImpl implements FileRegExportService {
	private static final Log log = LogFactory.getLog(FileRegExportServiceImpl.class);

	protected static final String TPL_QUERY_SQL = "select t.* from doc_export_tpl t where t.doc_type_val=?";
	private static final Object TPL_FIELD_NAME = "TPL_FILENAME";
	@Autowired
	private HibernateTemplate hibernateTemplate;
	@Autowired
	FileRegDao fielRegDao;
	
	public File getGeneratePhoneRecordExportFile(int docTypeVal, Long id) {
		File tpl = null, gen = null;
		InputStream is = null;
		OutputStream os = null;
		int count = 0;
		tpl = getTplPathByDocTypeVal(docTypeVal);

		try {
			gen = FileUtils.getFile(FileUtils.getTempDirectory() + "/" + UUID.randomUUID().toString() + ".doc");
			is = new FileInputStream(tpl);
			os = new FileOutputStream(gen);
			HWPFDocument doc = new HWPFDocument(is);
			Map<String, String> map = getFilledUpTplDataModel(docTypeVal, id);
			if(map.get("RECEIVE_TIME") != null){
				String v = map.get("RECEIVE_TIME");
				v = StringUtils.split(v, " ")[0];
				map.put("RECEIVE_TIME", v);
			}

			for (int i = 0; i < doc.getBookmarks().getBookmarksCount(); i++) {
				final Bookmark bookmark = doc.getBookmarks().getBookmark(i);
				String value = null;
				if (!StringUtils.isEmpty(bookmark.getName()) && map.containsKey(bookmark.getName()) && !StringUtils.isEmpty(value = map.get(bookmark.getName())) ) {
					final Range range = new Range(bookmark.getStart(), bookmark.getEnd(), doc);
					
					if (range.text().length() > 0) {
						range.replaceText(value, false);
					} else {
						range.insertBefore(value);
					}
					count++;
				}
				if(bookmark.getName().equals("barCode")){
					final Range range = new Range(bookmark.getStart(), bookmark.getEnd(), doc);
					Section sec = range.getSection(0);
					
//					range.insertBefore(this.encodeBase64File("d:\\pdf417.bmp"));
				}
			}
			Assert.isTrue(count > 0, "模板损坏:模板文件中未找到预置书签");
			doc.write(os);
		} catch (FileNotFoundException e) {
			log.error("模板文件未找到:" + e.getMessage(), e);
			throw new RuntimeException("模板文件未找到:" + e.getMessage());
		} catch (IOException e) {
			log.error("模板文件读取异常:" + e.getMessage(), e);
			throw new RuntimeException("模板文件读取异常:" + e.getMessage());
		}catch (Exception e) {
			log.error("模板文件读取异常:" + e.getMessage(), e);
			throw new RuntimeException("模板文件读取异常:" + e.getMessage());
		} finally {
			try {
				if (is != null) {
					is.close();
				}
				if (os != null) {
					os.close();
				}
				
			} catch (IOException e) {
			}
		}

		return gen;
	}

	
	public File getGenerateExportFile(int docTypeVal, Long id) {
		FileReg fr = fielRegDao.find(id);
		File tpl = null, gen = null;
		tpl = getTplPathByDocTypeVal(docTypeVal);
		gen = FileUtils.getFile(FileUtils.getTempDirectory() + "/" + UUID.randomUUID().toString() + ".docx");
		Map<String, String> map = getFilledUpTplDataModel(docTypeVal, id);
		
		try {
			if(map.get("RECEIVE_TIME") != null){
				String v = map.get("RECEIVE_TIME");
				DateFormat df = new SimpleDateFormat("yyyy-MM-dd");
				v = StringUtils.split(v, " ")[0];
				DateFormat df2 = new SimpleDateFormat("yyyy年MM月dd日");
				Date d = df.parse(v);
				map.put("RECEIVE_TIME", df2.format(d));
			}
			if("无".equals(map.get("SECURITY_GRADE"))){
				map.put("SECURITY_GRADE", "");
			}
			WordOperator oper = new WordOperator(tpl.getAbsolutePath(),gen.getAbsolutePath(),map);
			oper.processText();
			oper.processPicture("barCode", BarCodeUtil.createBarCode(fr), Document.PICTURE_TYPE_BMP, 0d, 0d);
			oper.outFile();
		} catch (Exception e) {
			e.printStackTrace();
		}
		return gen;
	}

	private File getTplPathByDocTypeVal(int docTypeVal) {
		File tpl = null;
		String tplPath = Thread.currentThread().getContextClassLoader().getResource("templates").getPath() + getTplFilenameByDocTypeVal(docTypeVal);
		tpl = FileUtils.getFile(tplPath);
		return tpl;
	}

	private String getTplFilenameByDocTypeVal(final int docTypeVal) {
		HibernateCallback<Map<String, Object>> action = new HibernateCallback<Map<String, Object>>() {
			@SuppressWarnings("unchecked")
			public Map<String, Object> doInHibernate(Session session) throws HibernateException, SQLException {
				Query q = session.createSQLQuery(TPL_QUERY_SQL);
				q.setInteger(0, docTypeVal);
				q.setResultTransformer(Transformers.ALIAS_TO_ENTITY_MAP);
				return (Map<String, Object>) q.uniqueResult();
			}
		};
		Map<String, Object> rs = hibernateTemplate.execute(action);
		return (String) rs.get(TPL_FIELD_NAME);
	}

	public Map<String, String> getFilledUpTplDataModel(final int docTypeVal, final Long id) {
		final String sqlQueryA = "select t.SN,t.FORM_UNIT,t.DOC_NUMBER,t.COPIES,t.TITLE,t.RECEIVE_TIME,T.SECURITY_GRADE from file_reg t  where t.id=?";
		final String sqlQueryB = "select t.SN,t.PHONE_UNIT,t.PHONE_PERSON,t.PHONE_TIME,t.TELEPHONE,t.PHONE_CONTENT," +
				"t.LEADER_OPINION,t.HANDLE_RESULT,t.HANDLE_UNIT,t.HANDLE_OPERATOR from file_phonerecord t where t.id=?";
		HibernateCallback<Map<String, String>> action = new HibernateCallback<Map<String, String>>() {
			@SuppressWarnings("unchecked")
			public Map<String, String> doInHibernate(Session session) throws HibernateException, SQLException {
				Query q = null;
				if(docTypeVal==DocType.TEL_RCD_DOC.ordinal()+1){
					q = session.createSQLQuery(sqlQueryB);
				}else{
					q = session.createSQLQuery(sqlQueryA);
				}
				q.setLong(0, id);
				q.setResultTransformer(Transformers.ALIAS_TO_ENTITY_MAP);
				return (Map<String, String>) q.uniqueResult();
			}
		};
		return hibernateTemplate.execute(action);
	}

}
